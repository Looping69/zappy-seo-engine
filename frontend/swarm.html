<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zappy Swarm | Neon Neural Circuit</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #F8FAFC;
            font-family: 'Plus Jakarta Sans', sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .hud {
            position: absolute;
            z-index: 10;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        .glass {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(15, 23, 42, 0.1);
        }

        .thought-bubble {
            position: absolute;
            padding: 10px 14px;
            background: white;
            color: #0F172A;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 700;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            pointer-events: none;
            transform: translate(-50%, -130%);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0;
            z-index: 20;
            border-bottom: 3px solid transparent;
            width: 180px;
            line-height: 1.4;
        }

        #agent-detail-panel {
            position: absolute;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            width: 320px;
            display: none;
            pointer-events: auto;
            border-radius: 2rem;
        }

        .tag {
            font-size: 10px;
            font-weight: 800;
            text-transform: uppercase;
            padding: 4px 10px;
            border-radius: 6px;
            color: white;
        }

        .neon-glow {
            filter: drop-shadow(0 0 8px currentColor);
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>

    <div class="hud p-10 flex flex-col justify-between">
        <div class="flex justify-between items-start">
            <div class="glass p-8 rounded-[2rem] max-w-sm shadow-2xl shadow-slate-200/50">
                <div id="progression-box">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-[10px] text-slate-400 font-bold uppercase tracking-widest">Production
                            Progress</span>
                        <span id="global-percent" class="text-orange-600 font-black text-[11px]">0%</span>
                    </div>
                    <div class="w-full h-1.5 bg-slate-100 rounded-full overflow-hidden">
                        <div id="global-progress-bar" class="h-full bg-orange-500 transition-all duration-1000"
                            style="width: 0%"></div>
                    </div>
                </div>
                <div class="mt-4 flex items-center gap-2">
                    <div class="w-1.5 h-1.5 rounded-full bg-emerald-500 animate-pulse"></div>
                    <span class="text-[9px] text-slate-400 font-bold uppercase tracking-widest">Sync Active</span>
                </div>
            </div>

            <div class="flex flex-col items-end gap-4 pointer-events-auto">
                <div class="glass px-8 py-5 rounded-full flex items-center gap-8 shadow-xl shadow-slate-200/40">
                    <div class="flex items-center gap-3">
                        <div class="w-3 h-3 rounded-full bg-orange-500 animate-ping"></div>
                        <span class="text-slate-900 text-[11px] font-black uppercase tracking-widest">Quantum State
                            Live</span>
                    </div>
                    <a href="/ui"
                        class="bg-slate-900 text-white px-6 py-2.5 rounded-full text-[11px] font-black uppercase transition-all hover:scale-105 active:scale-95 shadow-lg shadow-slate-900/10">Dashboard</a>
                </div>
                <button onclick="resetCamera()"
                    class="glass px-8 py-4 rounded-full text-slate-900 text-[11px] font-black uppercase hover:bg-slate-50 transition-all shadow-lg active:scale-95 border border-slate-200/50">Reset
                    Viewport</button>
            </div>
        </div>

        <div id="agent-detail-panel" class="glass p-10 shadow-2xl shadow-slate-300/50 border-slate-200">
            <div id="detail-tag" class="inline-block tag mb-6">RESEACHER</div>
            <h3 id="detail-name" class="text-3xl font-black text-slate-900 italic mb-3">Agent ID: 001</h3>
            <p id="detail-mission" class="text-slate-500 text-sm mb-8 italic leading-relaxed">Synthesizing multi-modal
                knowledge streams into a coherent neural map...</p>

            <div class="space-y-6">
                <div class="bg-slate-50 p-5 rounded-2xl border border-slate-100">
                    <span class="text-[10px] text-slate-400 font-black uppercase tracking-widest">Current Stream</span>
                    <p id="detail-op" class="text-slate-900 text-sm font-bold mt-1">Extracting Latent Semantic Clusters
                    </p>
                </div>
                <div class="pt-2 px-1">
                    <span class="text-[10px] text-slate-400 font-black uppercase tracking-widest">Active Circuit
                        Vector</span>
                    <p id="detail-path" class="text-orange-600 font-mono text-[11px] font-bold mt-2">VEC_99 //
                        NODE_ALPHA // STACK_04</p>
                </div>
            </div>
        </div>

        <div class="flex justify-center items-center">
            <div
                class="glass px-10 py-4 rounded-full text-[11px] text-slate-400 font-black uppercase tracking-widest flex gap-8 shadow-2xl shadow-slate-200/60">
                <span class="flex items-center gap-2">üñ±Ô∏è LEFT: ROTATE</span>
                <span class="flex items-center gap-2">üïπÔ∏è RIGHT: PAN</span>
                <span class="flex items-center gap-2">üîò ZOOM: SCROLL</span>
            </div>
        </div>
    </div>

    <div id="bubbles-container"></div>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Lighter scene colors
        scene.background = new THREE.Color(0xF8FAFC);
        // Add subtle fog for depth on light background
        scene.fog = new THREE.Fog(0xF8FAFC, 20, 100);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        camera.position.set(0, 10, 40);

        // Lighting - brighter for light mode
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedAgent = null;
        let isJobActive = false;

        // AGENT COLORS BY PHASE
        const colors = {
            // Phase 1: Research (Blues/Cyans)
            seo: 0x00d4ff,
            medical: 0x00f2ff,
            competitor: 0x00ffcc,
            // Phase 2: Synthesis (Purple)
            synthesizer: 0xbc13fe,
            // Phase 3: Writing (Oranges)
            clinical: 0xff6b00,
            empathetic: 0xff9500,
            practical: 0xffb700,
            innovative: 0xffd300,
            // Phase 4-7: Evaluation (Reds/Greens)
            judge: 0xff003c,
            critique: 0xff4466,
            seo_final: 0x24ff00
        };

        // Agents grouped by phase - they work independently within each phase
        const agentData = [
            // PHASE 1: RESEARCH (Independent - each only sees keyword)
            { id: 1, name: 'SEO Research', role: 'Research', phase: 1, color: colors.seo, mission: 'Analyzing search intent, SERP features, and keyword variations.', op: 'Intent Classification', facts: ['Intent: Informational', 'Word count: 2000', 'SERP: Featured Snippets'] },
            { id: 2, name: 'Medical Research', role: 'Research', phase: 1, color: colors.medical, mission: 'Extracting medical facts, mechanisms, and safety information.', op: 'Medical Fact Mining', facts: ['12 key facts found', 'FDA sources verified', 'Contraindications mapped'] },
            { id: 3, name: 'Competitor Research', role: 'Research', phase: 1, color: colors.competitor, mission: 'Identifying content gaps and unique angles.', op: 'Gap Analysis', facts: ['5 content gaps', '3 unique angles', 'Competitor weak points'] },

            // PHASE 2: SYNTHESIS (Receives all research at once)
            { id: 4, name: 'Synthesizer', role: 'Synthesis', phase: 2, color: colors.synthesizer, mission: 'Combining all research into a unified content strategy.', op: 'Strategy Fusion', facts: ['Primary angle set', 'Structure defined', 'Word count: 2000'] },

            // PHASE 3: WRITING (Independent - each sees only the strategy)
            { id: 5, name: 'Clinical Writer', role: 'Writing', phase: 3, color: colors.clinical, mission: 'Drafting with clinical authority and medical precision.', op: 'Clinical Draft', facts: ['Tone: Authoritative', 'Sources cited: 8', 'Word count: 2100'] },
            { id: 6, name: 'Empathetic Writer', role: 'Writing', phase: 3, color: colors.empathetic, mission: 'Drafting with warmth and patient understanding.', op: 'Empathetic Draft', facts: ['Tone: Supportive', 'Readability: Grade 8', 'Engagement: High'] },
            { id: 7, name: 'Practical Writer', role: 'Writing', phase: 3, color: colors.practical, mission: 'Drafting with actionable, step-by-step guidance.', op: 'Practical Draft', facts: ['Steps: 7', 'Actionable items: 12', 'Clarity: Optimal'] },
            { id: 8, name: 'Innovative Writer', role: 'Writing', phase: 3, color: colors.innovative, mission: 'Drafting with modern, forward-thinking perspective.', op: 'Innovative Draft', facts: ['Fresh angles: 3', 'Novel structure', 'Engagement: Peak'] },

            // PHASE 4+: EVALUATION (Receives all drafts at once)
            { id: 9, name: 'Judge', role: 'Judging', phase: 4, color: colors.judge, mission: 'Evaluating all drafts and selecting the best one.', op: 'Draft Comparison', facts: ['Scoring 4 drafts', 'Synthesis check', 'Winner selected'] },
            { id: 10, name: 'Medical Critic', role: 'Critique', phase: 5, color: colors.critique, mission: 'Verifying medical accuracy and safety compliance.', op: 'Medical Review', facts: ['Claims verified: 15', 'Accuracy: 98%', 'Safety: Approved'] },
            { id: 11, name: 'SEO Finalizer', role: 'SEO', phase: 6, color: colors.seo_final, mission: 'Optimizing meta tags and adding schema markup.', op: 'Final Polish', facts: ['Meta optimized', 'Schema added', 'Links inserted'] }
        ];

        const agents = [];
        let globalJobProgress = 0;
        let currentShapeObjective = 'CUBE'; // Default
        const shapes = ['CUBE', 'SPHERE', 'PYRAMID'];
        let shapeCycleIndex = 0;

        agentData.forEach((data, i) => {
            const group = new THREE.Group();

            // NEON CORE
            const geometry = new THREE.SphereGeometry(0.4, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: data.color,
                emissive: data.color,
                emissiveIntensity: 1.5,
                shininess: 100
            });
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);

            // NEON GLOW
            const glowGeo = new THREE.SphereGeometry(0.8, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({ color: data.color, transparent: true, opacity: 0.15 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            group.add(glow);

            group.position.set(0, 0, 0); // Start at center
            scene.add(group);

            // INFINITE TRAIL SYSTEM
            const trailGeo = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(300000 * 3); // Support for 300k vertices
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeo.setDrawRange(0, 0);

            const trailMat = new THREE.LineBasicMaterial({
                color: data.color,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const trail = new THREE.Line(trailGeo, trailMat);
            scene.add(trail);

            // Informative Thought Bubble
            const bubbleEl = document.createElement('div');
            bubbleEl.className = 'thought-bubble';
            bubbleEl.style.borderBottomColor = new THREE.Color(data.color).getStyle();
            document.getElementById('bubbles-container').appendChild(bubbleEl);

            agents.push({
                mesh: group,
                trail: trail,
                trailPoints: [],
                target: new THREE.Vector3(),
                noiseOffset: Math.random() * 5000,
                data: data,
                bubble: bubbleEl,
                thoughtTimer: 0,
                factIndex: 0
            });
        });

        // Grid helper for light mode aesthetics
        const grid = new THREE.GridHelper(200, 50, 0xE2E8F0, 0xF1F5F9);
        grid.position.y = -20;
        scene.add(grid);

        // OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const boundary = 25;

        // Phase positions - agents orbit around their phase's "memory node"
        const phasePositions = {
            1: new THREE.Vector3(-20, 0, 0),   // Research phase (left)
            2: new THREE.Vector3(-10, 0, 0),   // Synthesis phase
            3: new THREE.Vector3(0, 0, 0),     // Writing phase (center)
            4: new THREE.Vector3(10, 0, 0),    // Judge phase
            5: new THREE.Vector3(15, 0, 0),    // Critique phase
            6: new THREE.Vector3(20, 0, 0)     // SEO Final phase (right)
        };

        // Memory nodes visualization
        const memoryNodes = [];
        [1, 2, 3, 4, 5, 6].forEach(phase => {
            const geometry = new THREE.OctahedronGeometry(0.8, 0);
            const material = new THREE.MeshPhongMaterial({
                color: 0x6366f1,
                emissive: 0x6366f1,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.6
            });
            const node = new THREE.Mesh(geometry, material);
            node.position.copy(phasePositions[phase]);
            node.userData.phase = phase;
            scene.add(node);
            memoryNodes.push(node);
        });

        // Track which agent is currently active (sequential execution)
        let currentActiveAgentIndex = 0;
        let activePhase = 1;

        function getCurrentPhaseFromProgress(progress) {
            // Map progress to phases
            if (progress < 15) return 1;      // Research
            if (progress < 25) return 2;      // Synthesis
            if (progress < 50) return 3;      // Writing
            if (progress < 65) return 4;      // Judge
            if (progress < 85) return 5;      // Critique
            return 6;                          // SEO Final
        }

        function getActiveAgentInPhase(phase, progress) {
            const phaseAgents = agents.filter(a => a.data.phase === phase);
            if (phaseAgents.length === 0) return null;

            // Determine which agent in this phase is active based on sub-progress
            let subProgress;
            if (phase === 1) subProgress = progress / 15;
            else if (phase === 2) subProgress = (progress - 15) / 10;
            else if (phase === 3) subProgress = (progress - 25) / 25;
            else if (phase === 4) subProgress = (progress - 50) / 15;
            else if (phase === 5) subProgress = (progress - 65) / 20;
            else subProgress = (progress - 85) / 15;

            const agentIdx = Math.min(Math.floor(subProgress * phaseAgents.length), phaseAgents.length - 1);
            return phaseAgents[agentIdx];
        }

        function updateAgentTargets(time) {
            if (!isJobActive) {
                // When idle, agents gently orbit their phase position
                agents.forEach((agent, i) => {
                    const phase = agent.data.phase;
                    const basePos = phasePositions[phase];
                    const angle = time * 0.0002 + i * 0.5;
                    agent.target.set(
                        basePos.x + Math.cos(angle) * 3,
                        basePos.y + Math.sin(angle * 0.7) * 2,
                        basePos.z + Math.sin(angle) * 3
                    );
                    agent.isActive = false;
                });
                return;
            }

            activePhase = getCurrentPhaseFromProgress(globalJobProgress);
            const activeAgent = getActiveAgentInPhase(activePhase, globalJobProgress);

            agents.forEach((agent, i) => {
                const phase = agent.data.phase;
                const basePos = phasePositions[phase];
                const t = time * 0.001;

                if (activeAgent && agent === activeAgent) {
                    // ACTIVE AGENT: Energetic movement, working on task
                    agent.isActive = true;
                    if (!agent.moodTimer || time > agent.moodTimer) {
                        // Sporadic movement showing "work"
                        const workRadius = 6;
                        agent.target.set(
                            basePos.x + (Math.random() - 0.5) * workRadius * 2,
                            basePos.y + (Math.random() - 0.5) * workRadius,
                            basePos.z + (Math.random() - 0.5) * workRadius * 2
                        );
                        agent.moodTimer = time + 200 + Math.random() * 400;
                    }
                } else if (phase < activePhase) {
                    // COMPLETED AGENTS: Rest near their phase's memory node
                    agent.isActive = false;
                    const restAngle = i * Math.PI / 3 + t * 0.1;
                    agent.target.set(
                        basePos.x + Math.cos(restAngle) * 2,
                        basePos.y + 0.5,
                        basePos.z + Math.sin(restAngle) * 2
                    );
                } else if (phase === activePhase) {
                    // WAITING IN PHASE: Gentle orbit waiting for turn
                    agent.isActive = false;
                    const waitAngle = i * Math.PI / 2 + t * 0.3;
                    agent.target.set(
                        basePos.x + Math.cos(waitAngle) * 5,
                        basePos.y + Math.sin(t + i) * 1.5,
                        basePos.z + Math.sin(waitAngle) * 5
                    );
                } else {
                    // FUTURE PHASES: Dormant, distant orbit
                    agent.isActive = false;
                    const dormantAngle = t * 0.05 + i;
                    agent.target.set(
                        basePos.x + Math.cos(dormantAngle) * 8,
                        basePos.y - 5,
                        basePos.z + Math.sin(dormantAngle) * 8
                    );
                }
            });

            // Animate memory nodes - pulse when receiving data
            memoryNodes.forEach((node, idx) => {
                const phase = idx + 1;
                if (phase === activePhase) {
                    node.material.emissiveIntensity = 0.8 + Math.sin(time * 0.01) * 0.4;
                    node.rotation.y += 0.02;
                    node.scale.setScalar(1.2 + Math.sin(time * 0.005) * 0.2);
                } else if (phase < activePhase) {
                    node.material.emissiveIntensity = 0.5;
                    node.rotation.y += 0.005;
                    node.scale.setScalar(1.0);
                } else {
                    node.material.emissiveIntensity = 0.1;
                    node.scale.setScalar(0.8);
                }
            });
        }

        // Interaction Lines (Synapses) - now shows data flow to memory nodes
        const synapseGeo = new THREE.BufferGeometry();
        const synapseMat = new THREE.LineBasicMaterial({ color: 0x6366f1, transparent: true, opacity: 0.4 });
        const synapses = new THREE.LineSegments(synapseGeo, synapseMat);
        scene.add(synapses);

        // Phase flow lines (permanent connections between memory nodes)
        const flowGeo = new THREE.BufferGeometry();
        const flowPositions = [];
        for (let i = 1; i < 6; i++) {
            const from = phasePositions[i];
            const to = phasePositions[i + 1];
            flowPositions.push(from.x, from.y, from.z, to.x, to.y, to.z);
        }
        flowGeo.setAttribute('position', new THREE.Float32BufferAttribute(flowPositions, 3));
        const flowMat = new THREE.LineDashedMaterial({
            color: 0x94a3b8,
            transparent: true,
            opacity: 0.3,
            dashSize: 0.5,
            gapSize: 0.3
        });
        const flowLines = new THREE.LineSegments(flowGeo, flowMat);
        flowLines.computeLineDistances();
        scene.add(flowLines);

        function updateSynapses() {
            const positions = [];
            if (isJobActive) {
                // Draw lines from active agent to its phase's memory node
                agents.forEach((agent, i) => {
                    if (agent.isActive) {
                        const memNode = memoryNodes[agent.data.phase - 1];
                        positions.push(
                            agent.mesh.position.x, agent.mesh.position.y, agent.mesh.position.z,
                            memNode.position.x, memNode.position.y, memNode.position.z
                        );
                    }
                });

                // Connect completed agents to their memory nodes (fainter)
                agents.forEach(agent => {
                    if (agent.data.phase < activePhase) {
                        const memNode = memoryNodes[agent.data.phase - 1];
                        positions.push(
                            agent.mesh.position.x, agent.mesh.position.y, agent.mesh.position.z,
                            memNode.position.x, memNode.position.y, memNode.position.z
                        );
                    }
                });
            }
            synapseGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now();
            updateAgentTargets(time);
            updateSynapses();

            agents.forEach(agent => {
                // Lerping for smooth movement towards quantized grid targets
                agent.mesh.position.lerp(agent.target, isJobActive ? 0.08 : 0.02);

                // Add to persistent trail
                agent.trailPoints.push(agent.mesh.position.clone());

                const posAttr = agent.trail.geometry.attributes.position;
                const count = agent.trailPoints.length;
                posAttr.setXYZ(count - 1, agent.mesh.position.x, agent.mesh.position.y, agent.mesh.position.z);
                agent.trail.geometry.setDrawRange(0, count);
                posAttr.needsUpdate = true;

                // Informative Bubble logic - ONLY for active agent
                const vector = agent.mesh.position.clone();
                vector.project(camera);

                const screenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (vector.y * -0.5 + 0.5) * window.innerHeight;

                agent.bubble.style.left = `${screenX}px`;
                agent.bubble.style.top = `${screenY}px`;

                // Only show thought bubbles for the currently active agent
                if (isJobActive && agent.isActive && time > agent.thoughtTimer) {
                    const fact = agent.data.facts[agent.factIndex];
                    agent.bubble.innerHTML = `
                        <div class="text-[9px] font-black uppercase mb-1 opacity-50">${agent.data.role} WORKING</div>
                        <div class="text-slate-900">${fact}</div>
                    `;
                    agent.bubble.style.opacity = '1';
                    agent.bubble.style.transform = 'translate(-50%, -130%) scale(1)';

                    setTimeout(() => {
                        agent.bubble.style.opacity = '0';
                        agent.bubble.style.transform = 'translate(-50%, -120%) scale(0.95)';
                    }, 3000);

                    agent.factIndex = (agent.factIndex + 1) % agent.data.facts.length;
                    agent.thoughtTimer = time + 4000 + Math.random() * 2000;
                } else if (!agent.isActive) {
                    // Hide bubbles for non-active agents
                    agent.bubble.style.opacity = '0';
                }
            });

            if (selectedAgent) {
                const targetPos = selectedAgent.mesh.position.clone();
                const camTargetPos = targetPos.clone().add(new THREE.Vector3(0, 5, 12));
                camera.position.lerp(camTargetPos, 0.05);
                camera.lookAt(targetPos);
                controls.enabled = false;
            } else {
                controls.enabled = true;
                controls.update();
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('click', (event) => {
            // Prevent deselect when clicking on the sidebar
            if (event.target.closest('.hud')) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(agents.map(a => a.mesh), true);

            if (intersects.length > 0) {
                const clickedGroup = intersects[0].object.parent;
                const agent = agents.find(a => a.mesh === clickedGroup);
                if (agent) selectAgent(agent);
            } else {
                resetCamera();
            }
        });

        function selectAgent(agent) {
            selectedAgent = agent;
            const panel = document.getElementById('agent-detail-panel');
            panel.style.display = 'block';

            document.getElementById('detail-tag').innerText = agent.data.role;
            document.getElementById('detail-tag').style.background = new THREE.Color(agent.data.color).getStyle();
            document.getElementById('detail-name').innerText = agent.data.name;
            document.getElementById('detail-mission').innerText = agent.data.mission;
            document.getElementById('detail-op').innerText = agent.data.op;
            document.getElementById('detail-path').innerText = `VECTOR_${Math.floor(Math.random() * 999)} / HYPER_NODE / ${agent.data.role.toUpperCase()}`;
        }

        function resetCamera() {
            selectedAgent = null;
            document.getElementById('agent-detail-panel').style.display = 'none';
        }

        async function fetchProgress() {
            try {
                const res = await fetch('/keywords');
                const data = await res.json();
                const active = data.keywords.find(k => k.status === 'generating');

                isJobActive = !!active; // SET GLOBAL STATE

                if (active) {
                    const lRes = await fetch(`/content/logs/${active.id}`);
                    const lData = await lRes.json();
                    if (lData.logs.length > 0) {
                        const last = lData.logs[lData.logs.length - 1];
                        const p = Math.max(0, last.percent);
                        globalJobProgress = p; // SYNC PROGRESS
                        document.getElementById('global-percent').innerText = p + '%';
                        document.getElementById('global-progress-bar').style.width = p + '%';
                    }
                } else {
                    if (isJobActive) {
                        // Job just finished, clear for next cycle
                        shapeCycleIndex = (shapeCycleIndex + 1) % shapes.length;
                        currentShapeObjective = shapes[shapeCycleIndex];
                    }
                    globalJobProgress = 0;
                    document.getElementById('global-percent').innerText = '0%';
                    document.getElementById('global-progress-bar').style.width = '0%';
                }
            } catch (e) { }
        }

        animate();
        setInterval(fetchProgress, 5000);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>